#
# Test how UPDATE detects what columns need to be read (or generated) in a row
#
# stored column depends on virtual column depends on updated column.
# this tests TABLE::mark_virtual_columns_for_write()
#
create table t1 (a int, b int as (a+1), c int as (b+1) stored);
insert t1 set a=1;
select * from t1;
update t1 set a=2;
select * from t1;
drop table t1;
#
# one keypart is virtual, the other keypart is updated
# this tests TABLE::mark_columns_needed_for_update()
#
create table t1 (a int, c int as(a), p varchar(20) as(y), y char(20), index (p,c));
insert into t1 (a,y) values(1, "yyy");
update t1 set a = 100 where a = 1;
drop table t1;

#
# note: prefix keys below
#
create table t1 (
  a varchar(10000),
  b varchar(3000),
  c varchar(14000) generated always as (concat(a,b)) virtual,
  d varchar(5000) generated always as (b) virtual,
  e int(11) generated always as (10) virtual,
  h int(11) not null primary key,
  index(c(100), d(20)));
insert t1 (a,b,h) values (repeat('g', 10000), repeat('x', 2800), 1);
update t1 set a = repeat(cast(1 as char), 2000);
drop table t1;

create table t1 (
  a varchar(10000),
  b varchar(3000),
  c varchar(14000) generated always as (concat(a,b)) virtual,
  i varchar(5000) generated always as (b) virtual,
  d varchar(5000) generated always as (i) virtual,
  e int(11) generated always as (10) virtual,
  h int(11) not null primary key,
  index(c(100), d(20)));
insert t1 (a,b,h) values (repeat('g', 10000), repeat('x', 2800), 1);
update t1 set a = repeat(cast(1 as char), 2000);
drop table t1;
#
# UPDATE disguised as INSERT
#
create table t1(a blob not null, b int, c varbinary (10) generated always as (a) virtual, unique (c(9)));
insert t1 (a,b) values ('a', 1);
replace t1 set a = 'a',b =1;
insert t1 (a,b) values ('a', 1) on duplicate key update a='b', b=2;
select * from t1;
drop table t1;
